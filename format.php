<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Import export from QCM direct text files.
 *
 * @package    qformat_qcmdirect
 * @copyright  2013 Jean-Michel Vedrine
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

// History :
// Version 1.0 (2007) import text files generated by Neoptec WinWord macros.
// Version 1.1 (2010) also import text files generated by realkQuest 1.0.0 export.


// QCM DIRECT FORMAT
//
// NEOPTEC, QCM DIRECT, REALQUEST are trademarks of NEOPTEC Montpellier France
//
// This Moodle class provides all functions necessary to import and export
// multiple choice questions in this format:
//
//  Question text
//  Choice #1
//  Choice #2
//  Choice #3   V
//  Choice #4
//    (blank line next absolutely necessary since it
//     triggers the question input and causes input to start all over.)
//
// Several correct answers are allowed
// Each correct answer must be folloved by a tab and the V character (for Vrai = True in French).
//
// Be sure to reword "None of the above" type answer as "None of these" (etc.) so that choices can
//  be randomized
//
// Text files created by this format will only work on WINDOWS because CR+LF are used as end of lines.
// Also it will only import files created by softwares like MSWORD (ISO8859-1 encoding, CR+LF end of line)
// or NEOPTEC REALQUEST (UTF-16LE encoding, CR+LF end of line).

class qformat_qcmdirect extends qformat_default {

    public function provide_import() {
        return true;
    }
    public function provide_export() {
        return true;
    }

    public function readquestions($lines) {
        define ('UTF32_BIG_ENDIAN_BOM'   , chr(0x00) . chr(0x00) . chr(0xFE) . chr(0xFF));
        define ('UTF32_LITTLE_ENDIAN_BOM', chr(0xFF) . chr(0xFE) . chr(0x00) . chr(0x00));
        define ('UTF16_BIG_ENDIAN_BOM'   , chr(0xFE) . chr(0xFF));
        define ('UTF16_LITTLE_ENDIAN_BOM', chr(0xFF) . chr(0xFE));
        define ('UTF8_BOM'               , chr(0xEF) . chr(0xBB) . chr(0xBF));
		
		$gradeoptionsfull = question_bank::fraction_options_full();

        // First implode lines again.
        $texte = implode($lines);

        // Detect file encoding
        // word produce UTF-16LE files
        // RealQuest produce ISO-8859-1 files.
        $first2 = substr($texte, 0, 2);
        $first3 = substr($texte, 0, 3);
        $first4 = substr($texte, 0, 3);

        if ($first3 == UTF8_BOM) {
            $encoding = 'UTF-8';
        } else if ($first4 == UTF32_BIG_ENDIAN_BOM) {
            $encoding = 'UTF-32BE';
        } else if ($first4 == UTF32_LITTLE_ENDIAN_BOM) {
            $encoding = 'UTF-32LE';
        } else if ($first2 == UTF16_BIG_ENDIAN_BOM) {
            $encoding = 'UTF-16BE';
        } else if ($first2 == UTF16_LITTLE_ENDIAN_BOM) {
            $encoding = 'UTF-16LE';
        } else {
            $encoding = 'ISO-8859-1';
        }

        // Convert texte to UTF-8.
        $texte = textlib::convert($texte, $encoding, 'utf-8');
        // Then split at windows CR+LF end of lines.
        $endchar = "\r\n";
        $newlines = explode($endchar, $texte);

        $i = 0;
        // Build empty question.
        $questions = array();
        $question = $this->defaultquestion();
        while ($i < count($newlines)) {
            if ($newlines[$i] != '') {
                // Start of a new question.
                $newquest = true;
                while ($i < count($newlines) && $newlines[$i] != '') {
                    $nowline = $newlines[$i];
                    if ($newquest) {
                        $question->qtype = 'multichoice';
                        $question->name = $this->create_default_question_name($nowline, get_string('questionname', 'question'));
                        $question->questiontext = htmlspecialchars($nowline, ENT_QUOTES);
                        $question->questiontextformat = FORMAT_HTML;
                        $question->correctfeedback = '';
                        $question->partiallycorrectfeedback = '';
                        $question->incorrectfeedback = '';
                        $rightans = 0;
                        $totalans = 0;
                    } else {
                        // Start of answers choices.
                        if (preg_match('/\tV$/i', $nowline)) {
                            // Correct answer found
                            // strip tab+V at end of line.
                            $question->answer[] = array(
                                    'text' => trim(htmlspecialchars(textlib::substr($nowline, 0, -2), ENT_QUOTES)),
                                    'format' => FORMAT_HTML,
                                    );
                            $question->fraction[] = 1;
                            $question->feedback[] = array('text' => '', 'format' => FORMAT_HTML);
                            $rightans++;
                            $totalans++;
                        } else {
                            // Incorrect answer found.
                            $question->answer[] = array(
                                    'text' => trim(htmlspecialchars($nowline, ENT_QUOTES)),
                                    'format' => FORMAT_HTML,
                                    );
                            $question->fraction[] = 0;
                            $question->feedback[] = array('text' => '', 'format' => FORMAT_HTML);
                            $totalans++;
                        }

                    }
                    $newquest = false;
                    $i++;
                }
                // Question is terminated.
                $question = $this->add_blank_combined_feedback($question);
                if ($totalans < 2) {
                    $this->error(get_string('notenoughchoices', 'qformat_qcmdirect', $totalans),
                    $question->questiontext);
                } else if ($rightans == 0) {
                    $this->error(get_string('mustspecifyrightanswer', 'qformat_qcmdirect'),
                    $question->questiontext);
                } else if ($rightans == 1) {
                    $question->single = 1;
                    $questions[] = $question;
                } else {
                    $question->single = 0;
					foreach ($question->fraction as $key => $fraction) {
					    if ($fraction >0.9) {
						    $question->fraction[$key] = match_grade_options($gradeoptionsfull, 1/$rightans, 'nearest');
					    }
					}
                    $questions[] = $question;
                }

                // Clear array for next question.
                $question = $this->defaultquestion();
            }
            $i++;
        }
        return ($i > 0 ? $questions : false);
    }

    public function readquestion($lines) {
        // This is no longer needed but might still be called by default.php.
        return;
    }

    /**
     * Do the export
     * We need to override this function because we don't want any output
     * even a blank line for non multichoice questions.
     * @return stored_file
     */
    public function exportprocess() {
        global $CFG, $DB, $USER;

        // Get the questions (from database) in this category
        // only get q's with no parents (no cloze subquestions specifically).
        if ($this->category) {
            $questions = get_questions_category($this->category, true);
        } else {
            $questions = $this->questions;
        }

        $count = 0;

        // Results are first written into string (and then to a file)
        // so create/initialize the string here.
        $expout = '';

        // Iterate through questions.
        foreach ($questions as $question) {
            // Used by file api.
            $contextid = $DB->get_field('question_categories', 'contextid',
                    array('id' => $question->category));
            $question->contextid = $contextid;

            // Do not export hidden questions.
            if (!empty($question->hidden)) {
                continue;
            }

            // Only export multichoice questions.
            if ($question->qtype != 'multichoice') {
                continue;
            }

            // Export the question displaying message.
            $count++;

            if (question_has_capability_on($question, 'view', $question->category)) {
                $questiontxt = html_to_text($question->questiontext, 0, false);
                $expout .= textlib::convert( $questiontxt , 'utf-8', 'ISO-8859-1')."\r\n";
                foreach ($question->options->answers as $answer) {
                    $answertxt = html_to_text($answer->answer, 0, false);
                    $epilog = ($answer->fraction > 0) ? "\tV\r\n" : "\r\n";
                    $expout .= textlib::convert( $answertxt , 'utf-8', 'ISO-8859-1').$epilog;
                }
                // Add empty line to delimit questions.
                $expout .= "\r\n";
            }
        }

        // Continue path for following error checks.
        $course = $this->course;
        $continuepath = "$CFG->wwwroot/question/export.php?courseid=$course->id";

        // Did we actually process anything ?
        if ($count == 0) {
            print_error('noquestions', 'question', $continuepath);
        }

        return $expout;
    }
}

